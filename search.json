[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Tiffani puts code here, mostly.\n\nMore about Tiffani\nTiffani Ashley Bell is the Founding Executive Director of The Human Utility, a platform bringing people together from around the world to help people in the United States with their water bills.\nThe Human Utility has helped thousands people with over $1MM in crowdfunded assistance and is a Y Combinator-backed not-for-profit.\nTiffani was a 2017 Technology & Democracy Fellow at the Harvard Kennedy School of Government researching water affordability and designing a water affordability subsidy. She was a 2014 Code for America Fellow. Previously, she was the CEO and Founder of Pencil You In, enabling over 2,000 local businesses to accept appointments online, bringing many of them online for the first time.\nTiffani is a programmer who earned a Bachelor of Science in Systems & Computer Science from Howard University. As a programmer, she has given back to the profession by keynoting numerous technical conferences including two of the largest: the O’Reilly Open Source Conference (OSCON) and GitHub Universe. In 2015, she presented a paper on the use of programming and data science in designing a water affordability intervention at the Bloomberg Data for Good Exchange (D4GX) conference.\nShe spoke at TED in 2022, where was dubbed “Humanitarian Programmer”.\nTiffani graduated in 2021 as a Sloan Fellow from the Stanford Graduate School of Business with a Master of Science in Management. She graduated in 2008 with a Bachelor of Science in Systems and Computer Science from Howard University.\nFinally, Tiffani is a startup investor with investments in amazing companies such as Finix (payments), Goodr (surplus food), and Charityvest (DAF/charity software - exited), amongst others."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/on-volatility-driven-stops-chandelier-stops-in-ibkr/index.html",
    "href": "posts/on-volatility-driven-stops-chandelier-stops-in-ibkr/index.html",
    "title": "On Volatility-Driven Trailing Stops - Chandelier Stops via the Interactive Brokers API",
    "section": "",
    "text": "“Cut your losses, let your gains run…” (just not away)\nHaving a better methodology for stops and capturing unrealized gains became super important after a certain set of recent disappointing trades. Goldman ran up to an all-time-high of $825.25 ahead of a Jerome Powell speech on September 22, 2025. The positions I held at that point were the result of a few days of analysis, familiarizing myself with more of the statistical properties of the things I am trading—especially in tandem with working through the Quantitative Methods book for the CFA exam in February 2026.\nI did a five-year analysis of Goldman’s daily returns dating back to January 2020. They showed 2.36 excess kurtosis and positive skew. In English, that is a stock that has small losses here and there, but a few very large gains. This was a very large gain…and yet I did not capture enough of this move.\nI experienced a gain of 584.8% on a GS Oct 2026 800 call after GS rocketed to that all-time-high. Unfortunately, my stop did not hug this position tightly enough and in the subsequent drop gave back nearly half those gains. This was sad and preventable!\n\n\nWhat is a “chandelier stop”?\nInteractive Brokers’s Trader Workstation offers trailing stops. They are fixed, however. You can set a percentage or a fixed value for the stop. But, then you must through the rigamarole of determining what percentage or absolute value to use. And even after you do that, though, that’s it. The parameter you set for how wide (permissive) or how narrow (restrictive) your trailing stop is doesn’t change.\nI have been wanting to understand if having a stop that adjusts dynamically based on an underlying’s volatility made sense. And hey! It turns out this exists and it is called a chandelier stop. I first read about this in Dr. Alexander Elder’s Come Into My Trading Room. It uses the average true range of an underlying to turn volatility into a way to determine where stops should go.\nA chandelier stop is set with volatility in mind and may retreat as prices move around. This is basically the mechanical embodiment of breathing room. It can be used for both entries and exits.\nAs Elder says\n\nWhen traders are long, it hangs their stops from the highest peak reached by that trend, like a chandelier hangs from the tallest point in the room. As prices move up, the Chadelier Exit, suspended from the highest point of that trend, also rises. It tracks volatility as well as prices, as its distance from the peak grows with the rise in volatility. […] There is no telling how high a trend may go, and a Chandelier will rise until prices peel off from the ceiling and hit that stop.\n\nHow much breathing room it has is, of course, the product of the parameters used to create the stop. The chandelier stop consists of a lookback period and the average true range (both to calculate volatility).\n\n\nWorking with Interactive Brokers’s API (v10.37+)\nWhat’s nice is that Interactive Brokers has an API and Python libraries for programmatically interacting with your trading account. The APIs are extensive and take some effort to understand, though. (Some things are not documented very well, others are not documented at all unless you’ve joined a mailing list for support.) Once you get everything running, it is nothing to then start putting on and managing trades via Python—including creating a chandelier stop to manage a long call position that is in the green!\nThe code below uses Interactive Brokers’s Python library ibapi version 10.37 to execute trades using IBGateway version 10.37 starting in October 2025.\nThis works, but is also still a work in progress.\n\n\nibkr-chandelier.py\n\n# Written to accommodate IBApi libraries 10.30 or above.\n# Also built this using 10.37 version of IBGateway.\n\nimport os\nimport time\nimport datetime\nimport threading\n\nimport pandas as pd\nimport yfinance as yf\n\nfrom ibapi.client import *\nfrom ibapi.wrapper import *\nfrom ibapi.contract import *\nfrom ibapi.utils import iswrapper\nfrom ibapi.ticktype import TickTypeEnum\n\nfrom decimal import Decimal, ROUND_CEILING\n\nATR_MULTIPLIER = 3  # 3x ATR for stocks, 3-4x for options\nATR_PERIOD = 10 # Standard ATR period\nLOOKBACK_PERIOD = 10 # Days to look back for highest high\n\n# Need to round to next nickel to accommodate minimum order tick sizes\ndef round_to_nickel(price):\n    return float((Decimal(str(price)) / Decimal('0.05')).quantize(Decimal('1'), rounding = ROUND_CEILING) * Decimal('0.05'))\n\nclass ChandelierStopManager:\n    def __init__(self, ibkr_client, ibkr_account):\n        self.ibkr_client = ibkr_client\n        self.ibkr_account = ibkr_account\n\n    def _cancel_existing_stops(self, ticker):\n        # Cancel existing stop orders for a ticker\n        open_orders = self.ib.openTrades()\n        \n        cancelled_count = 0\n        for trade in open_orders:\n            if (trade.contract.symbol == ticker and trade.order.orderType in ['STP', 'TRAIL']):\n                self.ibkr_client.cancelOrder(trade.order)\n                cancelled_count += 1\n        \n        if cancelled_count &gt; 0:\n            print(f\"  Cancelled { cancelled_count } existing stop order(s) ...\")\n\n\n    # Calculate a chandelier stop for a given ticker\n    def calculate_chandelier_stop(self, ticker, multiplier = ATR_MULTIPLIER, period = ATR_PERIOD):\n        print(f\"\\nCalculating Chandelier Stop for { ticker }...\")\n        \n        # Download recent price data\n        data = yf.download(ticker, period = '2mo', interval = '1d', progress = False)\n        \n        if data.empty:\n            print(f\"Yikes: Could not download data for { ticker } ...\")\n            return None\n        \n        # Calculate True Range components\n        high_low = (data['High'][ticker] - data['Low'][ticker])\n        high_close = abs(data['High'][ticker] - data['Close'][ticker].shift())\n        low_close = abs(data['Low'][ticker] - data['Close'][ticker].shift())\n        \n        # True Range = max of the three\n        true_range = pd.concat([high_low, high_close, low_close], axis = 1).max(axis = 1)\n        \n        # Average True Range (ATR)\n        atr = true_range.rolling(period).mean()\n        current_atr = atr.iloc[-1]\n        \n        # Current price and highest high\n        current_price = data['Close'][ticker].iloc[-1]\n        highest_high = data['High'][ticker].tail(period).max()\n        \n        # Chandelier Stop = Highest High - (Multiplier × ATR)\n        stop_level = round_to_nickel(highest_high - (multiplier * current_atr))\n        \n        # Calculate distance to stop as percentage\n        distance_pct = ((current_price - stop_level) / current_price) * 100\n        \n        result = {\n            'ticker': ticker,\n            'current_price': current_price,\n            'atr': current_atr,\n            'highest_high': highest_high,\n            'stop_level': stop_level,\n            'distance_pct': distance_pct,\n            'timestamp': datetime.datetime.now()\n        }\n        \n        # Print results\n        print(f\"\\n{ '=' * 50 }\")\n        print(f\"Ticker: { ticker }\")\n        print(f\"Current Price: ${ current_price:.2f}\")\n        print(f\"ATR ({ period }): ${ current_atr:.2f}\")\n        print(f\"Highest High ({ period }d): ${ highest_high:.2f}\")\n        print(f\"Chandelier Stop: ${ stop_level:.2f}\")\n        print(f\"Distance to Stop: { distance_pct:.1f}%\")\n        print(f\"{ '=' * 50 }\\n\")\n        \n        return result\n    \n    # Calculate and update Chandelier stops for all open positions\n    def update_stops_for_all_positions(self, multiplier = ATR_MULTIPLIER):\n        if not self.ibkr_client.connected:\n            print(\"Ooopps! You're not connected to IBKR...\")\n            return\n            \n        self.ibkr_client.reqPositions()\n\n        time.sleep(10)\n\n        positions = self.ibkr_client.positions\n            \n        if not positions:\n            print(\"\\nNo positions to update\")\n            return\n            \n        print(f\"\\n{ '=' * 70 }\")\n        print(\"UPDATING CHANDELIER STOPS...\")\n        print(f\"{ '=' * 70 }\\n\")\n            \n        for position in positions:\n            if position[1] &gt; 0:  # Only for long positions\n                ticker = position[0].symbol\n                quantity = position[1]\n                    \n                print(f\"\\n--- Processing { ticker } ---\")\n                    \n                # Calculate Chandelier stop level\n                stop_data = self.calculate_chandelier_stop(ticker, multiplier)\n                    \n                if stop_data is None:\n                    print(f\"Skipping { ticker } - could not calculate stop ...\")\n                    continue\n                    \n                stop_level = stop_data['stop_level']\n                    \n                # Cancel any existing stop orders for this position\n                self._cancel_existing_stops(ticker)\n                    \n                # Place new stop order\n                self._place_stop_order(position[0], quantity, stop_level)\n\n    def _cancel_existing_stops(self, ticker):\n        # Cancel existing stop orders for a ticker\n        self.ibkr_client.reqAllOpenOrders()\n\n        time.sleep(10)\n            \n        cancelled_count = 0\n        for trade in self.ibkr_client.open_orders:\n            if (trade[1].symbol == ticker and trade[2].orderType in ['STP', 'TRAIL']):\n                self.ibkr_client.cancelOrder(trade[0], OrderCancel())\n                cancelled_count += 1\n            \n        if cancelled_count &gt; 0:\n            print(f\"  Cancelled { cancelled_count } existing stop order(s) ...\")\n\n    def _place_stop_order(self, contract, quantity, stop_price):\n        # Place a stop-loss order\n        order = Order()\n        order.action = 'SELL'\n        order.orderType = 'STP'\n        order.totalQuantity = quantity\n        order.auxPrice = stop_price  # Stop trigger price\n        order.account = self.ibkr_account\n        order.tif = 'GTC'\n\n        contract.exchange = 'SMART'\n            \n        oid = self.ibkr_client.nextId()\n\n        # Place the order\n        trade = self.ibkr_client.placeOrder(oid, contract, order)\n            \n        print(f\"  ✓ Placed stop order at ${ stop_price:.2f}\")\n        print(f\"    Quantity: { quantity }\")\n            \n        return trade\n\n\n# This is set up to serve as the client and the wrapper\nclass IBApiClient(EWrapper, EClient):\n    IBKR_GATEWAY_ADDRESS = '127.0.0.1'\n    IBKR_TESTING_PORT = 4002\n    IBKR_LIVE_PORT = 4001\n\n    LIVE_DATA = 1\n    FROZEN_DATA = 2 \n    DELAYED_DATA = 3\n    FROZEN_DELAYED_DATA = 4\n\n    def __init__(self, address, port, client_id):\n        print(\"Getting started with IBKR...\")\n        EClient.__init__(self, self)\n        EWrapper.__init__(self)\n                \n        # Establish the connection to TWS/IB Gateway\n        # TWS supports up to 32 simultaneous client connections\n        self.connect(address, port, client_id)\n        self.connected = True\n        self.positions = []\n        self.open_orders = []\n\n        # Launch the client thread\n        # The 'run' function executes in a loop that repeats as long\n        # as the client is connected.\n        thread = threading.Thread(target = self.run)\n        thread.start()\n\n    @iswrapper\n    def nextValidId(self, orderId):\n        self.orderId = orderId\n\n    @iswrapper\n    def nextId(self):\n        self.orderId += 1 \n        return self.orderId\n    \n    @iswrapper\n    def currentTime(self, current_time):\n        t = datetime.datetime.fromtimestamp(current_time)\n        print(f'Current time: { t }')\n\n    @iswrapper\n    def contractDetails(self, request_id, contractDetails):\n        attrs = vars(contractDetails)\n        print(\"\\n\".join(f\"{ name }: { value }\" for name, value in attrs.items()))\n\n    @iswrapper\n    def contractDetailsEnd(self, reqId):\n        return super().contractDetailsEnd(reqId)\n\n    @iswrapper\n    def historicalData(self, request_id, bar):\n        print(bar)\n        return super().historicalData(request_id, bar)\n    \n    @iswrapper\n    def historicalDataEnd(self, reqId, start, end):\n        print(f\"Historical data ended for { reqId }. Started at { start }, ending at { end }\")\n        return super().historicalDataEnd(reqId, start, end)\n\n    @iswrapper\n    def error(self, reqId, errorCode, errorString, advancedOrderRejectJson = \"\"):\n        print(f'Error: { errorCode }: { errorString }')\n        return super().error(reqId, errorCode, errorString, advancedOrderRejectJson)\n    \n    @iswrapper\n    def tickPrice(self, reqId, tickType, price, attrib):\n        print(f\"Request ID: { reqId }, tickType: { TickTypeEnum.to_str(tickType) }, price: { price }, attrib: { attrib }\")\n\n    @iswrapper\n    def tickSize(self, reqId, tickType, size):\n        print(f\"Request ID: { reqId }, tickType: { TickTypeEnum.to_str(tickType)}, size: { size }\")\n\n    @iswrapper\n    def tickString(self, request_id, tickType, value):\n        print(f\"Request ID: { request_id }, tickType: { TickTypeEnum.to_str(tickType) }, value: { value }\")\n\n    @iswrapper\n    def accountSummary(self, reqId, account, tag, value, currency):\n        return super().accountSummary(reqId, account, tag, value, currency)\n    \n    @iswrapper\n    def updatePortfolio(self, contract: Contract, position: float, marketPrice: float, marketValue: float, averageCost: float, unrealizedPNL: float, realizedPNL: float, accountName: str):\n        print(\"UpdatePortfolio.\", \"Symbol:\", contract.symbol, \"SecType:\", contract.secType, \"Exchange:\", contract.exchange, \"Position:\", position, \"MarketPrice:\", marketPrice, \"MarketValue:\", marketValue, \"AverageCost:\", averageCost, \"UnrealizedPNL:\", unrealizedPNL, \"RealizedPNL:\", realizedPNL, \"AccountName:\", accountName)\n        \n    @iswrapper\n    def updateAccountTime(self, timeStamp: str):\n        print(\"UpdateAccountTime. Time:\", timeStamp)\n\n    @iswrapper\n    def updateAccountValue(self, key: str, val: str, currency: str, accountName: str):\n        print(\"UpdateAccountValue. Key:\", key, \"Value:\", val, \"Currency:\", currency, \"AccountName:\", accountName)\n\n    @iswrapper\n    def position(self, account: str, contract: Contract, position: Decimal, avgCost: float):\n        self.positions.append([contract, position, avgCost])\n        print(\"Position.\", \"Account:\", account, \"Contract:\", contract, \"Position:\", position, \"Avg cost:\", avgCost)\n        \n    def positionEnd(self):\n       print(\"PositionEnd\")\n\n    def orderStatus(self, orderId: OrderId, status: str, filled: Decimal, remaining: Decimal, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):\n        print(\"OrderStatus. Id:\", orderId, \"Status:\", status, \"Filled:\", decimalMaxString(filled), \"Remaining:\", decimalMaxString(remaining), \"AvgFillPrice:\", floatMaxString(avgFillPrice), \"PermId:\", intMaxString(permId), \"ParentId:\", intMaxString(parentId), \"LastFillPrice:\", floatMaxString(lastFillPrice), \"ClientId:\", intMaxString(clientId), \"WhyHeld:\", whyHeld, \"MktCapPrice:\", floatMaxString(mktCapPrice))\n\n    def openOrderEnd(self):\n        print(\"OpenOrderEnd\")\n\n\n    @iswrapper\n    def get_positions(self):\n        # Get all current positions from an account\n        if not self.connected:\n            print(\"Error: You're not connected to IBKR ...\")\n            return []\n        \n        positions = self.positions()\n        print(f\"\\nFound { len(positions) } open positions\")\n        \n        for pos in positions:\n            print(f\"  • {pos.contract.symbol}: { pos.position} contracts @ ${ pos.avgCost:.2f}\")\n        \n        return positions\n\n    # Order-related wrappers\n    @iswrapper\n    def openOrder(self, orderId, contract, order, orderState):\n        self.open_orders.append([orderId, contract, order, orderState])\n\n        print(f\"Order ID: { orderId}, contract: { contract }, order: { order }\")\n        return super().openOrder(orderId, contract, order, orderState)\n    \n    @iswrapper\n    def orderStatus(self, orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice):\n        print(f\"Order ID: { orderId }, status: { status }, filled: { filled }, remaining: { remaining }, lastFillPrice: { lastFillPrice }, permID: { permId }, avgFillPrice: { avgFillPrice }\")\n        return super().orderStatus(orderId, status, filled, remaining, avgFillPrice, permId, parentId, lastFillPrice, clientId, whyHeld, mktCapPrice)\n    \n    @iswrapper\n    def execDetails(self, reqId, contract, execution):\n        print(f\"Execution details. Request ID: { reqId }, contract: { contract }, execution: { execution }\")\n        return super().execDetails(reqId, contract, execution)\n\ndef update_once(ibkr_client):\n    # Example: Connect to IBKR and update stops once\n    print(\"\\n\" + \"=\" * 70)\n    print(\"One-Time Stop Update\")\n    print(\"=\" * 70)\n    \n    try:\n        ibkr_account = os.getenv(\"IBKR_ACCOUNT_ID\") \n        manager = ChandelierStopManager(ibkr_client = ibkr_client, ibkr_account = ibkr_account)\n        manager.update_stops_for_all_positions(multiplier = ATR_MULTIPLIER)\n    except KeyError:\n        print(\"Yikes! No IBKR account ID available...\")\n\nif __name__ == \"__main__\":\n    print(\"\\n\" + \"=\" * 70)\n    print(\"CHANDELIER STOP SYSTEM ...\")\n    print(\"=\" * 70)\n\n    # Connect to Interactive Brokers API via IB Gateway (v10.37 in this case...)\n    ib_client = IBApiClient(IBApiClient.IBKR_GATEWAY_ADDRESS, IBApiClient.IBKR_TESTING_PORT, 10252025)\n    \n    time.sleep(7)\n\n    update_once(ib_client)\n    \n\nAnd when it runs, this is what you get! This run is based on my paper trading account with an existing SPY position (shares, not options) I bought when it was at $540.59-ish.\n\n\n\nChandelier stop paper trading account run\n\n\n\n\nWhat’s next?\nElder himself admits that the “…negative side of Chandelier Exits is that they give up a great deal of profit. Three Average True Ranges can amount to a lot of money in a volatile market.” He recommends experimenting with the Average True Range coefficient (ATR_MULTIPLIER in my code).\nThe code listed here does not include the portion that takes a volatility and calculates the option price to set a stop. I will update with that soon.\nFinally, some of this code could be cleaned up. The Interactive Brokers API callback methods are mostly from their developer documentation."
  },
  {
    "objectID": "posts/live-at-the-opra-options-order-flow-data-with-python/index.html",
    "href": "posts/live-at-the-opra-options-order-flow-data-with-python/index.html",
    "title": "Live at the OPRA - Watching options order flow with Python",
    "section": "",
    "text": "I trade options via Interactive Brokers and their Trader Workstation software. At a certain point, though, I realized their option chain interface did not always show the true last price a particular option traded at. Bid-ask info would be updated continuously, but not necessarily last price. I was then potentially getting a false sense of what was actually happening at any given strike and actually missing out on useful information. And the thing is, I pay for real-time data from the exchanges via IBKR, so there was no good reason to be seeing stale price data.\nI remembered that Databento offers real-time OPRA data feeds, so I decided to sign up for that. It’s $199/mo, but I would argue it’s been totally worth it to see options order flow in real-time all throughout the trading day. You also get statistics about all the options you’re interested in when the exchanges close for the day.\nThis code sample doesn’t deviate much from the sample Databento offers to get you started with live data, but for a while this is what I used to watch real-time options order flow every weekday.\n\nimport databento as db\n\ndb.enable_logging(\"INFO\")\n\nsymbols = [\"GS    251219C00850000\",]\n\nlive_client = db.Live(API_KEY)\n\nlive_client.subscribe(\n    dataset = \"OPRA.PILLAR\",\n    schema = \"status\",\n    symbols = symbols,\n    stype_in = \"raw_symbol\",\n)\n\nlive_client.subscribe(\n    dataset = \"OPRA.PILLAR\",\n    schema = \"tcbbo\",\n    symbols = symbols,\n    stype_in = \"raw_symbol\",\n)\n\nlive_client.subscribe(\n    dataset = \"OPRA.PILLAR\",\n    schema = \"statistics\",\n    symbols = symbols,\n    stype_in = \"raw_symbol\",\n)\n\nlive_client.add_callback(print)\nlive_client.start()\n\nThis turned into:\n\n\n\nOPRA data flow from Databento\n\n\nUnfortunately, the raw output from the feed is very hard to read and follow what is happening with the options you’re interested in.\nIn particular, the feed shows which option is which in the order flow via the instrument_id, but it’s a number, not a somewhat human-readable identifier (with issuer, date, and strike such as GS 251219C00850000). Or even better, a Goldman Sachs December 2025 850 call. The feed gives you a listing of what instrument_id is tied to which option and strike, but that happens when the feed first launches. After that, there’s no easy way to know what you’re looking at. That calls for some modifications!\nI cooked up something that makes order flow much more readable.\n\nimport os\nimport databento as db\n\n# Prices don't come in 2-decimal form\nOPT_PRICE_DIV = 1000000000\n\nsymbol_mappings = {}\n\ndef order_flow_print(order_flow_data):\n    msg_type = type(order_flow_data)\n\n    if(msg_type == db.SymbolMappingMsg):\n        instrument_id = order_flow_data.instrument_id\n        issuer_symbol = order_flow_data.stype_out_symbol\n        symbol_mappings[instrument_id] = issuer_symbol\n    elif(msg_type == db.CMBP1Msg):\n        header = order_flow_data.hd\n        instrument_id = header.instrument_id\n        order_price = order_flow_data.price / OPT_PRICE_DIV\n        order_size = order_flow_data.size\n        symbol_str = symbol_mappings[instrument_id]\n\n        bid_ask = order_flow_data.levels[0]\n        bid_price = bid_ask.bid_px / OPT_PRICE_DIV\n        ask_price = bid_ask.ask_px / OPT_PRICE_DIV\n        print(f\"{ symbol_str } - { order_size } @ ${ order_price }\")\n        print(f\"Bid: { bid_price }x{ bid_ask.bid_sz }  Ask: { ask_price }x{ bid_ask.ask_sz}\\n\")\n    \nif __name__ == \"__main__\":\n    try:\n        databento_api_key = os.getenv(\"DATABENTO_API_KEY\")\n        live_client = db.Live(databento_api_key)\n    except KeyError:\n        print(\"Oops! DATABENTO_API_KEY not found...\")\n\n    # Show all the order flow for a given issuer (in this case, Goldman Sachs and JP Morgan)\n    symbols = [\"GS.OPT\", \"JPM.OPT\", ]\n\n    live_client.subscribe(\n        dataset = \"OPRA.PILLAR\",\n        schema = \"status\",\n        symbols = symbols,\n        stype_in = \"parent\",\n    )\n\n    live_client.subscribe(\n        dataset = \"OPRA.PILLAR\",\n        schema = \"tcbbo\",\n        symbols = symbols,\n        stype_in = \"parent\",\n    )\n\n    live_client.subscribe(\n        dataset = \"OPRA.PILLAR\",\n        schema = \"statistics\",\n        symbols = symbols,\n        stype_in = \"parent\",\n    )\n\n    live_client.add_callback(order_flow_print)\n    live_client.start()\n\nAnd with much more readable output:\n\n\n\nUpdated OPRA order data flow from Databento\n\n\nOf course, it could be improved even from here, but that’s for another day. CFA and CMT studying awaits…"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Musings",
    "section": "",
    "text": "On Volatility-Driven Trailing Stops - Chandelier Stops via the Interactive Brokers API\n\n\n\ncode\n\nPython\n\nrisk management\n\nInteractive Brokers\n\nAPIs\n\n\n\n\n\n\n\n\n\nNov 6, 2025\n\n\nTiffani Ashley Bell\n\n\n\n\n\n\n\n\n\n\n\n\nLive at the OPRA - Watching options order flow with Python\n\n\n\ncode\n\noptions\n\nPython\n\nDatabento\n\nmarket microstructure\n\n\n\n\n\n\n\n\n\nNov 2, 2025\n\n\nTiffani Ashley Bell\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nOct 30, 2025\n\n\nTiffani Ashley Bell\n\n\n\n\n\nNo matching items"
  }
]